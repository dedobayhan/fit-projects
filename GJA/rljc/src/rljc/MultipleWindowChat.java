/*
 * Project: RLJC - Really Lightweight Jabber Client
 * Author:  Petr Zemek, xzemek02@stud.fit.vutbr.cz
 * 
 * Copyright (C) 2009 Petr Zemek
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

package rljc;

import java.awt.Dimension;
import java.awt.GridLayout;
import java.util.ArrayList;
import java.util.List;

/**
 * Multiple chats in a single window.
 */
public class MultipleWindowChat extends javax.swing.JFrame {
	
	/** Maximal number of chats. */
	private int maxChats = 0;
	/** Actual number of chats */
	private int currentChats = 0;
	/** Currently active chat panels. */
	private List<ChatPanel> chatPanels = new ArrayList<ChatPanel>();
	/** Close chat panels on dispose? */
	private boolean closeChatPanelsOnDispose = true;
	
	/**
	 * Constructs a new MultipleWindowChat object.
	 * 
	 * @param maxChats Maximal number of chats.
	 */
	public MultipleWindowChat(int maxChats) {
		initComponents();
		
		this.maxChats = maxChats;
		currentChats = 0;
	}
	
	/**
	 * Adds a new chat panel to the window.
	 * 
	 * @param chatPanelToAdd Chat panel to be added.
	 * @return True if the chat was added successfully, false otherwise
	 *         (there is no room for a new chat).
	 */
	public synchronized boolean addChatPanel(ChatPanel chatPanelToAdd) {
		if (currentChats < maxChats) {
			currentChats++;
			chatPanels.add(chatPanelToAdd);
			repositionAllChatPanels();
			setWindowTitle();

			return true;
		} else {
			return false;
		}
	}
	
	/**
	 * Removes the selected chat panel from this window. If the panel
	 * does not exist, nothing will happen.
	 * 
	 * @param chatPanel Chat panel that should be removed.
	 */
	public synchronized void removeChatPanel(ChatPanel chatPanel) {
		if (chatPanels.remove(chatPanel)) {
			currentChats--;
			repositionAllChatPanels();
			setWindowTitle();
		}
	} 
	
	/**
	 * Returns all chat panels in this window.
	 */
	public synchronized List<ChatPanel> getChatPanels() {
		 return chatPanels;
	}
	
	/**
	 * Sets a window title according to the number of chats.
	 */
	private synchronized void setWindowTitle() {
		if (currentChats == 1) {
			setTitle(chatPanels.get(0).getUserChat().getUser());
		} else {
			setTitle("RLJC Chat");
		}
	}
	
	/**
	 * Repositions all chat panels.
	 */
	private synchronized void repositionAllChatPanels() {
		if (currentChats != 0) {
			getContentPane().removeAll();
			int rows = currentChats % 2 == 0 ? currentChats / 2 : (currentChats / 2) + 1;
			int cols = currentChats % 2 == 0 ? currentChats / 2 : (currentChats / 2) + 1;
			getContentPane().setLayout(new GridLayout(rows, cols));
			for (ChatPanel chatPanel : chatPanels) {
				getContentPane().add(chatPanel);
				chatPanel.setClosable(currentChats > 1);
			}

			// Set dimensions
			Dimension d = new Dimension(200 * rows, 200 * rows);
			setMinimumSize(d);
			if (getSize().width < d.width) {
				setSize(d);
			}
			if (getSize().height < d.height) {
				setSize(d);
			}
			
			redoLayout();
		}
	}
	
	/**
	 * Disposes the window without closing all chat panels.
	 */
	public void disposeWithoutClosingChatPanels() {
		closeChatPanelsOnDispose = false;
		dispose();
	} 
	
	/**
	 * "Redos" the window layout.
	 */
	public void redoLayout() {
		doLayout();
		getContentPane().doLayout();
	}
	
	/** This method is called from within the constructor to
	 * initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is
	 * always regenerated by the Form Editor.
	 */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        org.jdesktop.application.ResourceMap resourceMap = org.jdesktop.application.Application.getInstance(rljc.App.class).getContext().getResourceMap(MultipleWindowChat.class);
        setTitle(resourceMap.getString("Form.title")); // NOI18N
        setName("Form"); // NOI18N
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosed(java.awt.event.WindowEvent evt) {
                formWindowClosed(evt);
            }
        });
        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                windowResized(evt);
            }
        });
        getContentPane().setLayout(new java.awt.GridLayout(1, 0));

        pack();
    }// </editor-fold>//GEN-END:initComponents

	/**
	 * Window was closed event.
	 * 
	 * @param evt Window event.
	 */
	private void formWindowClosed(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosed
		synchronized (this) {
			if (closeChatPanelsOnDispose) {
				// The toArray() metod is needed here because of possible
				// ConcurrentModificationException exception when iterating
				// over the chatPanels list (chatPanel.close() calls removeChatPanel,
				// which modifies the chatPanels list as well)
				for (Object chatPanel : chatPanels.toArray()) {
					((ChatPanel) chatPanel).close();
				}
			}
		}
	}//GEN-LAST:event_formWindowClosed

	/**
	 * Window was resized event.
	 * 
	 * @param evt Component event.
	 */
	private void windowResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_windowResized
		redoLayout();
	}//GEN-LAST:event_windowResized
	
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
	
}
